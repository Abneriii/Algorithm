






/*

LC.198.打家劫舍
2022.3.20:Hou:自己想出了动态规划的方法，自己用代码实现了。

*/
class Solution {
    public int rob(int[] nums) {
        //dp[i][j]表示第i间屋子，[j]=0表示截至目前+没偷这间屋子钱时的最大偷取金额;[j]=1表示截至目前+偷了这间屋子钱时的最大偷取金额
        int[][ ] dp=new int[nums.length][2];
        dp[0][0]=0;
        dp[0][1]=nums[0];
        for(int i=1;i<nums.length;i++){
             dp[i][0]=Math.max(dp[i-1][0],dp[i-1][1]);
             if(i==1){
                  dp[i][1]= Math.max(nums[1],nums[0]);
             }
             else{
                  dp[i][1]=Math.max(dp[i-1][0]+nums[i],dp[i-2][1]+nums[i]);
             }
            
        }
        return Math.max(dp[dp.length-1][0],dp[dp.length-1][1]);
       



    }
}


/*

LC.53.最大子数组和
2022.3.21:做出。

*/

class Solution {
    public int maxSubArray(int[] nums) {
        //dp[i]代表以nums[i]为结尾的连续子数组和的最大值
        int lastIndex=nums.length-1;
        int[] dp=new int[nums.length];
        dp[0]=nums[0];  
        int max=nums[0];
        for(int i=1;i<nums.length;i++){
            dp[i]=Math.max(nums[i],dp[i-1]+nums[i]);
            if(dp[i]>max){
                max=dp[i];
            }
        }
        return max;
    }
}


/
*
LC.62.不同路径
2022.3.22:Hou:看题解，懂了，自己代码实现了。
*
/
class Solution {
    public int uniquePaths(int m, int n) {
        //dp[i][j]表示从(0,0)到(i,j)的总路径数
        int[][] dp=new int[m][n];
        for(int i=0;i<m;i++) dp[i][0]=1;
        for(int j=0;j<n;j++) dp[0][j]=1;
       
        for(int i=1;i<m;i++){
            for(int j=1;j<n;j++){
                    dp[i][j]=dp[i][j-1]+dp[i-1][j];
            }
        }
        return dp[m-1][n-1];



    }
}





