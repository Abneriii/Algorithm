



//Hou自己想到了应该用回溯法，并自己用回溯法实现了。




/*

LC.55.跳跃游戏
2022.4.7:Hou:想到了用回溯法，用代码实现了，自己测试了几个例子，是正常的，但是leecode平台提交显示超时了，说明自己回溯法的实现时间复杂度高。
别人的题解中好像都没有用回溯法的。

*/

class Solution {
    int[] nums2;
    boolean res=false;
    public boolean canJump(int[] nums) {
        nums2=nums;
        int targetIndex=nums.length-1;
        canJump(0,targetIndex);
        return res;
    }

    public void canJump(int startIndex,int targetIndex ){
        if(startIndex+nums2[startIndex]>=targetIndex){
            res=true;
            return;
        }
        for(int i=nums2[startIndex];i>0;i--){
            canJump(startIndex+i,targetIndex);
        }
    }




}
















/*



LC.416.分割等和子集
2022.4.9:Hou：实现了，自己又测试了几个用例，结果是正确的，但是leecode平台提交显示超时了，说明自己回溯法的实现时间复杂度高。

*/
class Solution {
    int halfSum=0;
    boolean res=false;
    public boolean canPartition(int[] nums) {
        
        //
        int sum=0;
        for(int n:nums){
            sum+=n;
        }
        if(sum%2!=0) return false;
        halfSum=sum/2;
        canPartition(nums,0,0);
        return res;


    }

    public void canPartition(int[]nums,int startIndex,int currrentSum){
        if(currrentSum==halfSum){
            res=true;

        }
        for(;startIndex<nums.length;startIndex++){
            if(currrentSum+nums[startIndex]<=halfSum){
                canPartition(nums,startIndex+1,currrentSum+nums[startIndex]);
            }
        }


    }



    
}




























/
LC.494.目标和
2022.3.28:Hou:想到了用回溯法，用代码实现了，自己测试了几个例子，是正常的，但是leecode平台提交显示超时了，说明自己回溯法的实现时间复杂度高。
力扣官方题解的回溯法的思路和我的一样，时间复杂度也是指数级别，但是实现上有点不同，但是它的可以通过，不知道为什么。

/

public class LC494 {
    public static void main(String[] args) {
        int[] nums={1,1,1,1,1};
        System.out.println(findTargetSumWays(nums,3));
    }
    static int res=0;
    public static  int findTargetSumWays(int[] nums, int targetGap) {
        //回溯法
        findTargetSumWays(nums,0,targetGap,0);
        return res;

    }
    
    public static void findTargetSumWays(int[] nums,int startIndex,int targetGap,int prefix){
        if(startIndex==nums.length){
            if(targetGap==0){
                res++;
            }
            return;

        }
        
        for(;startIndex<nums.length;startIndex++){
             prefix=-1;
            while(prefix<1){
                prefix++;
                findTargetSumWays(nums,startIndex+1,(int)(targetGap-nums[startIndex]*Math.pow(-1,prefix)),prefix);
            }
            return;


        }
    }

}



















//LC.77.组合
//2022.3.15：Hou:"需要一个循环+递归的结构",回溯法。1h--用代码实现了自己的思路，通过了。
class Solution {
   
   List<List<Integer>> res=new ArrayList<>();
   int maxnum;
    public List<List<Integer>> combine(int n, int k) {
    maxnum=n;
    List<Integer> list=new ArrayList<>();
    combine(1,k,list);
    return res;

    }
       //need:还需要的整数个数；
    public void combine(int start,int need,List<Integer> list){
        if(need==0) {
            res.add(new ArrayList<>(list));
            list.remove(list.size()-1);
            return;
        }
        for(;start<=maxnum;start++){
            list.add(start);
            combine(start+1,need-1,list);
           
        }
        if(list.size()!=0){
                list.remove(list.size()-1);
        }
    }


}




/*

//LC.39.组合总和 。
2022.3.15:Hou："这道题的解法思路和LC.77很相似，但区别在于这道题同一个数字可以被无限制重复选取，
所以要在调用递归式传递参数时有区别。"。自己想出了算法，自己用代码实现算法，通过了。

class Solution {

    int[] candidatesArray;
    List<List<Integer>> res=new ArrayList<>();
    public List<List<Integer>> combinationSum(int[] candidates, int target) {
       //目标是target，list存储当前的内容，start
        
        candidatesArray=candidates;
        List<Integer> list=new ArrayList<>();
        combinationSum(0,target,list);
        return res;
    }
    public void combinationSum(int startIndex,int needTarget,List<Integer> list){
        if(needTarget==0){
            res.add(new ArrayList<>(list));
            list.remove(list.size()-1);
            return ;
        }

        for(;startIndex<candidatesArray.length;startIndex++){
            if(candidatesArray[startIndex]<=needTarget){
                list.add(candidatesArray[startIndex]);
                combinationSum(startIndex,needTarget-candidatesArray[startIndex],list);
            }
        }
        if(list.size()!=0){
                list.remove(list.size()-1);
            }

    }

}


/*

LC.40.组合总和 II
2022.3.15--Hou:算法思路应该没问题，但是最后有一点待完成的部分，还没有想好怎么做。

*/
class Solution {
    /*
    测试用例：[10,1,2,7,6,1,5]  8
    我的程序的输出：[[1,2,5],[1,7],[1,6,1],[2,6],[2,1,5],[7,1]]
    预期正确结果输出：[[1,1,6],[1,2,5],[1,7],[2,6]]
     */    


    int[] candidatesArray;
    List<List<Integer>> res=new ArrayList<>();
    public List<List<Integer>> combinationSum2(int[] candidates, int target) {
       //目标是target，list存储当前的内容，start
        
        candidatesArray=candidates;
        List<Integer> list=new ArrayList<>();
        combinationSum(0,target,list);
        
       /*
        Hou：题目中要求"candidates 中的每个数字在每个组合中只能使用 一次 。"，
        我理解为输出的结果不能有元素相同的数组，所以我的思路是将得到的res再进行处理去重，
        暂时的去重思路是用Set，但是提交执行结果说超出内存限制，可能这个去重方法不好，dai改进。
        */

        Set<List<Integer>> resSet=new HashSet<>();
        for(List<Integer> listHelp:res){
            Collections.sort(listHelp);
            if(!resSet.contains(listHelp)){
                  resSet.add(listHelp);
            }
        }
        res.clear();
        for(List<Integer> listHelp:resSet){
            res.add(listHelp);
        }
        
        return res;
    }
    public void combinationSum(int startIndex,int needTarget,List<Integer> list){
        if(needTarget==0){
            res.add(new ArrayList<>(list));
            list.remove(list.size()-1);
            return ;
        }

        for(;startIndex<candidatesArray.length;startIndex++){
            if(candidatesArray[startIndex]<=needTarget){
                list.add(candidatesArray[startIndex]);
                combinationSum(startIndex+1,needTarget-candidatesArray[startIndex],list);
            }
        }
        if(list.size()!=0){
                list.remove(list.size()-1);
            }
    }


}


/*
LC.216.组合总和 III
2022.3.13:有点思路，但思路有点问题。
2022.3.15:自己相出了算法，自己用代码实现了，通过了。

*/
class Solution {
    List<List<Integer>> res=new ArrayList<>();

    public List<List<Integer>> combinationSum3(int k, int n) {
        
        List<Integer> list=new ArrayList<>();
        combinationSum(k,n,1,list);
        return res;

    }
    public void combinationSum(int needAmount,int needSum,int nIndex,List<Integer> list){
        if(needAmount==0&&needSum==0){
            res.add(new ArrayList<>(list));
            list.remove(list.size()-1);
            return;
        }

        for(;nIndex<=9&&nIndex<=needSum&&needAmount!=0;nIndex++){
            if(nIndex<=needSum){
                list.add(nIndex);
                combinationSum(needAmount-1,needSum-nIndex,nIndex+1,list);
            }
        }
         if(list.size()!=0){
                list.remove(list.size()-1);
            }

}
}











/*

LC.377.组合总和Ⅳ
2022.3.16:Hou:"自己想出了算法：回溯法，自己用代码实现，但是leecode平台提交显示超时了，
       自己在本地测试结果是对的，应该是平台测试的数据样本大，所以就超时了，我的这个方法应该是非常初级
	   的回溯法，没有什么减枝优化，dai改进。"


*/

class Solution {
    int account=0;
    int[] numsAll;
    public int combinationSum4(int[] nums, int target) {
        numsAll=nums;
        combinationSum(target,0);
        return account;

    }

    public void combinationSum(int needTarget,int nIndex){
        if(needTarget==0){
            account++;
            return; 
        }

        for(;nIndex<numsAll.length;nIndex++){
            if(numsAll[nIndex]<=needTarget){
                int lastNum=numsAll[nIndex];
                combinationSum(needTarget-numsAll[nIndex],0);
            }
        }
        

    }


}



//NC.BM.55 没有重复项数字的全排列
/*
2022.3.17:Hou:“遍历数组以选定第一个数字，然后对数组中剩下的数字进行全排列,这是一种递归思想。代码实现有问题，
不知道是自己这个思路有问题，还是自己代码的实现方式有问题，代码未完成”。

*/


public class Solution {
    
    //Hou:“遍历数组以选定第一个数字，然后对数组中剩下的数字进行全排列”
        
    ArrayList<ArrayList<Integer>> res= new ArrayList<>();
    public ArrayList<ArrayList<Integer>> permute(int[] num) {
         
        //遍历数组元素，选取一个作为打头数字
        ArrayList<Integer> list=new ArrayList<>();
        Arrays.sort(num);
        boolean[] used=new boolean[num.length];
        
        fullPermute(0,num,list);
        return res;
    }
    
    
    public void fullPermute(int firstNumIndex,int[] num,ArrayList<Integer> list){
        if(list.size()==num.length){
            res.add(new ArrayList(list));
            list.remove(list.size()-1);
            return; 
        }
        for(;firstNumIndex<num.length;firstNumIndex++){
            if(!list.contains(num[firstNumIndex])){
               list.add(num[firstNumIndex]);
               fullPermute(firstNumIndex,num,list);
                
                
            }
           
        }
        
        
        
        
    }
    
    
    
    
    
    
}






/*

LC.518.零钱兑换 II
2022.3.22:Hou:此题用了最初级的回溯法，提交显示的是超出内存限制，自己又测试了几个用例，结果是正确的，说明暴力方法没错，但暴力的内存太费，需要优化。；




*/
class Solution {
    //回溯法
    int count=0;
    public int change(int amount, int[] coins) {
    change(amount,0,coins);
    return count;

    }


    public void change(int amount,int index,int[] coins){
        if(amount==0){
            count++;
            return;
        }
        for(;index<coins.length;index++){
            if(coins[index]<=amount){
                change(amount-coins[index],index,coins);
            }
        }


    }
}


